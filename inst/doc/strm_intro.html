<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<pre><code class="r">#load libraries
#load strm
library(strm)
library(rmarkdown)
#load package dependencies for the vignette
library(tidyr)
library(dplyr)
library(rgdal)
library(spdep)
library(rgeos)
library(sf)
library(knitr)
library(Ecdat)
</code></pre>

<p><code>strm</code> is an <code>R</code> package that fits spatio-temporal regression model based on Chi &amp; Zhu <em>Spatial Regression Models for the Social Sciences</em> (2019). The approach here fits a spatial error model while incorporating a temporally lagged response variable and temporally lagged explanatory variables.</p>

<p>This package builds on the <code>errorsarlm()</code> function from the <code>spatialreg</code> package.</p>

<p>This package is still under development. Please report bugs or constructive tips to issues <a href="https://github.com/mkamenet3/strm/issues">here</a>.</p>

<h1>Introduction</h1>

<p>Fit a spatial error model but include a temporally lagged response variable, temporally lagged explanatory variable, and temporally and spatially lagged explanatory variables.</p>

<p>Spatial error model at time \(t\):</p>

<p>\[Y_t = X_t \beta + u_t, u_t=\rho Wu_t + \varepsilon\]</p>

<p>Adding in a temporally lagged response variable and temporally lagged explanatory variable:</p>

<p>\[Y_t = X_t\beta_t + \beta_2Y_{t-1} + X_{t-1}\beta_3 + u_t, u_t=\rho Wu_t + \varepsilon\]</p>

<p>This becomes:</p>

<p>\[Y_t = Y_{t-1} \beta_2 + \rho W Y_t - \rho\beta_2 WY_{t-1} + X_t \beta_1 + X_{t-1}\beta_3 - W X_t \rho \beta_1 -WX_{t-1} \rho \beta_3 + \varepsilon\]</p>

<h2>Example 1: Produce in the United States</h2>

<p>(This example has been adapted from the <a href="https://cran.r-project.org/src/contrib/Archive/splm/"><code>splm</code></a> package vignette.)</p>

<p>The first data set we will use is the <strong>Produc</strong> data set from the <code>Ecdat</code> package. This data set is a panel of United States production data from 1970-1986. There are 816 observations by county in the United States. The variables we will use are:</p>

<ul>
<li><code>year</code>: year</li>
<li><code>state</code>: state in the United States</li>
<li><code>gsp</code>:</li>
<li><code>pcap</code>: private capital stock.</li>
<li><code>pc</code>: public capital.</li>
<li><code>emp</code>: labor input measured by employment in non-agricultural payrolls.</li>
<li><code>unemp</code>: state unemployment rate.</li>
</ul>

<p>We also load <strong>usaww</strong> (originally from the <a href="https://cran.r-project.org/src/contrib/Archive/splm/"><code>splm</code></a> package), a spatial weights matrix of the 48 continental United States based on second-order neighbors.</p>

<pre><code class="r">#load data example
data(&quot;Produc&quot;)
data(&quot;usaww&quot;)

#explore the data structures
str(Produc)
</code></pre>

<pre><code>## &#39;data.frame&#39;:    816 obs. of  10 variables:
##  $ state: Factor w/ 48 levels &quot;ALABAMA&quot;,&quot;ARIZONA&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ year : int  1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 ...
##  $ pcap : num  15033 15502 15972 16406 16763 ...
##  $ hwy  : num  7326 7526 7765 7908 8026 ...
##  $ water: num  1656 1721 1765 1742 1735 ...
##  $ util : num  6051 6255 6442 6756 7002 ...
##  $ pc   : num  35794 37300 38670 40084 42057 ...
##  $ gsp  : int  28418 29375 31303 33430 33749 33604 35764 37463 39964 40979 ...
##  $ emp  : num  1010 1022 1072 1136 1170 ...
##  $ unemp: num  4.7 5.2 4.7 3.9 5.5 7.7 6.8 7.4 6.3 7.1 ...
</code></pre>

<pre><code class="r">str(usaww)
</code></pre>

<pre><code>##  num [1:48, 1:48] 0 0 0 0 0 0 0 0.5 0.2 0 ...
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : chr [1:48] &quot;ALABAMA&quot; &quot;ARIZONA&quot; &quot;ARKANSAS&quot; &quot;CALIFORNIA&quot; ...
##   ..$ : chr [1:48] &quot;ALABAMA&quot; &quot;ARIZONA&quot; &quot;ARKANSAS&quot; &quot;CALIFORNIA&quot; ...
</code></pre>

<h3>Single Year Lag</h3>

<p>We next convert the spatial weights matrix to a list of spatial weights using the <code>mat2listw()</code> function from the <code>spdep</code> package and check the <code>class()</code> of the object:</p>

<pre><code class="r">#create list of spatial weights
usalw &lt;- mat2listw(usaww)
class(usalw)
</code></pre>

<pre><code>## [1] &quot;listw&quot; &quot;nb&quot;
</code></pre>

<p>Next, we perform the spatio-temporal regression model. We first create a formula using <code>as.formula()</code>. For this model, our response is <code>log(gsp)</code> and our explanatory variables are <code>log(pcap), log(pc), log(emp), unemp</code>.</p>

<p>For this analysis, we will limit the data to only 1970 and 1971 - two time periods.</p>

<p>We use the <code>strm()</code> function from the <code>strm</code> package. The first argument is the model formula. Given that the data is in <em>long</em> format, <code>strm</code> will create the lagged values for you as well as the lagged response in the right-hand side of the model. The next argument is <code>id</code>, which we set to &ldquo;state&rdquo; as each observation is taken at the state level. We then specify the name of the data set (<code>data=Produc</code>), the list of spatial weights (<code>listw = usalw</code>), <code>time=2</code>, we tell <code>strm</code> that the data is in <em>long</em> format by setting <code>wide=FALSE</code>, and lastly we pass an argument to filter observations where <code>year</code> is equal to either 1970 or 1971 (2 time periods).</p>

<pre><code class="r">formula1 &lt;-as.formula(log(gsp)  ~ log(pcap) + log(pc) + log(emp) + unemp)
out &lt;- strm(formula1, id=&quot;state&quot;, data=Produc, listw = usalw, time=2,wide=FALSE,
            filter_options=&quot;year==1970 | year==1971&quot;)
</code></pre>

<pre><code>## The spatio-temporal regression model fitted:
</code></pre>

<pre><code>## loggsp ~ logpcap + logpc + logemp + unemp + logpcap.Tlag1 + logpc.Tlag1 +     logemp.Tlag1 + unemp.Tlag1 + loggsp.Tlag1
</code></pre>

<pre><code class="r">summary(out)
</code></pre>

<pre><code>## 
## Call:spatialreg::errorsarlm(formula = modframe, listw = listw)
## 
## Residuals:
##         Min          1Q      Median          3Q         Max 
## -0.03855189 -0.00739710 -0.00061512  0.00585547  0.05119821 
## 
## Type: error 
## Coefficients: (asymptotic standard errors) 
##                  Estimate  Std. Error z value  Pr(&gt;|z|)
## (Intercept)    1.9946e-01  7.6150e-02  2.6193 0.0088117
## logpcap       -1.8587e-01  2.3251e-01 -0.7994 0.4240508
## logpc          1.4288e-05  2.5371e-01  0.0001 0.9999551
## logemp         8.2984e-01  1.9872e-01  4.1758 2.969e-05
## unemp          3.3262e-03  6.0468e-03  0.5501 0.5822638
## logpcap.Tlag1  1.9192e-01  2.2597e-01  0.8493 0.3956987
## logpc.Tlag1    1.7700e-02  2.5045e-01  0.0707 0.9436582
## logemp.Tlag1  -7.5794e-01  1.9659e-01 -3.8555 0.0001155
## unemp.Tlag1   -4.5510e-03  6.8513e-03 -0.6643 0.5065302
## loggsp.Tlag1   9.1257e-01  2.5405e-02 35.9204 &lt; 2.2e-16
## 
## Lambda: -0.0093887, LR test value: 0.00085418, p-value: 0.97668
## Asymptotic standard error: 0.20491
##     z-value: -0.045819, p-value: 0.96345
## Wald statistic: 0.0020994, p-value: 0.96345
## 
## Log likelihood: 128.249 for error model
## ML residual variance (sigma squared): 0.00027975, (sigma: 0.016726)
## Number of observations: 48 
## Number of parameters estimated: 12 
## AIC: -232.5, (AIC for lm: -234.5)
</code></pre>

<p>From the model summary output, we see that <code>strm</code> has included lagged variables (*.Tlag1) for each of the explanatory variables initially specified (<code>log(pcap), log(pc), log(emp), unemp</code>), as well as a lagged variable for the response (<code>log(gsp)</code>).</p>

<h3>With 2 Lags</h3>

<p>As the number of time periods in the data increase, so do the number of lags. If we now use the same model, but instead include an additional year (1972) and set <code>time=3</code>.</p>

<pre><code class="r">formula2 &lt;-as.formula(log(gsp)  ~ log(pcap) + log(pc) + log(emp) + unemp)
out &lt;- strm(formula2, id=&quot;state&quot;, data=Produc, listw= usalw, time=3,
            wide=FALSE,filter_options=&quot;year==1970 | year==1971 | year ==1972&quot;)
</code></pre>

<pre><code>## The spatio-temporal regression model fitted:
</code></pre>

<pre><code>## loggsp ~ logpcap + logpc + logemp + unemp + logpcap.Tlag1 + logpc.Tlag1 +     logemp.Tlag1 + unemp.Tlag1 + logpcap.Tlag2 + logpc.Tlag2 +     logemp.Tlag2 + unemp.Tlag2 + loggsp.Tlag1 + loggsp.Tlag2
</code></pre>

<p>After executing the <code>strm()</code> model, we apply the <code>summary()</code> function to the results object, <code>out</code>.</p>

<pre><code class="r">summary(out)
</code></pre>

<pre><code>## 
## Call:spatialreg::errorsarlm(formula = modframe, listw = listw)
## 
## Residuals:
##         Min          1Q      Median          3Q         Max 
## -0.02179096 -0.00525540  0.00041786  0.00461342  0.01653898 
## 
## Type: error 
## Coefficients: (asymptotic standard errors) 
##                 Estimate Std. Error z value  Pr(&gt;|z|)
## (Intercept)    0.2516030  0.0462216  5.4434 5.227e-08
## logpcap        0.0980899  0.1760534  0.5572   0.57742
## logpc          0.2284076  0.3163419  0.7220   0.47028
## logemp         0.2484005  0.1105107  2.2478   0.02459
## unemp         -0.0056502  0.0035709 -1.5823   0.11359
## logpcap.Tlag1 -0.2784667  0.3731087 -0.7463   0.45546
## logpc.Tlag1   -0.4567652  0.3651608 -1.2509   0.21099
## logemp.Tlag1   0.5172162  0.2297628  2.2511   0.02438
## unemp.Tlag1    0.0099326  0.0042575  2.3330   0.01965
## logpcap.Tlag2  0.1929118  0.2093529  0.9215   0.35681
## logpc.Tlag2    0.2527881  0.1388406  1.8207   0.06865
## logemp.Tlag2  -0.6862555  0.1397530 -4.9105 9.085e-07
## unemp.Tlag2   -0.0037672  0.0033893 -1.1115   0.26636
## loggsp.Tlag1   0.7593464  0.0720738 10.5357 &lt; 2.2e-16
## loggsp.Tlag2   0.1317338  0.0685188  1.9226   0.05453
## 
## Lambda: -0.77659, LR test value: 4.9975, p-value: 0.025385
## Asymptotic standard error: 0.18694
##     z-value: -4.1542, p-value: 3.2636e-05
## Wald statistic: 17.258, p-value: 3.2636e-05
## 
## Log likelihood: 162.5098 for error model
## ML residual variance (sigma squared): 5.8561e-05, (sigma: 0.0076525)
## Number of observations: 48 
## Number of parameters estimated: 17 
## AIC: -291.02, (AIC for lm: -288.02)
</code></pre>

<p>From the model summary output, we see that <code>strm</code> has now included two lagged variables (*.Tlag1 and *.Tlag2) for each of the explanatory variables initially specified, as well as two lags for the response variable.</p>

<h2>Example 2: Minor Civil Divisions in Wisconsin</h2>

<p>We use the example from <em>Spatial Regression Models for the Social Sciences</em> Chi &amp; Zhu (2019). The example uses population growth data from 2000 to 2010. Data are at the minor civil division (MCD) level in Wisconsin. There are two years of data: 2000 and 2010. The variables we will use are:</p>

<ul>
<li><code>LNP1000</code>: population growth from 2000 to 2010.</li>
<li><code>LNP0090</code>: population growth from 1990 to 2000.</li>
<li><code>POLD00</code>: percentage of the old population (age sixty-five and older) in 2000.</li>
<li><code>POLD90</code>: percentage of the old population (age sixty-five and older) in 1990.</li>
</ul>

<p>We load the <code>sptdmg3</code> .RData file that comes with the <code>strm</code> package using <code>data(sptdmg3)</code> and explore its <code>class()</code> and <code>names()</code>: </p>

<pre><code class="r">data(sptdmg3)
class(sptdmg3)
</code></pre>

<pre><code>## [1] &quot;SpatialPolygonsDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;
</code></pre>

<pre><code class="r">names(sptdmg3)
</code></pre>

<pre><code>## [1] &quot;STFID&quot;   &quot;X_COORD&quot; &quot;Y_COORD&quot; &quot;LNP1000&quot; &quot;LNP0090&quot; &quot;POLD00&quot;  &quot;POLD90&quot;
</code></pre>

<p>First, fit a standard linear regression model with population growth from 2000 to 2010 as the response variable and population growth from 1990 to 2000, the old population in 2000, and the old population in 1990 as the explanatory variables.</p>

<pre><code class="r">formula2 &lt;- as.formula(LNP1000 ~ LNP0090 + POLD00 + POLD90)
m2 &lt;- lm(formula2, data = sptdmg3)
summary(m2)
</code></pre>

<pre><code>## 
## Call:
## lm(formula = formula2, data = sptdmg3)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.69307 -0.06942 -0.01170  0.05636  1.08243 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  0.109237   0.009174  11.907  &lt; 2e-16 ***
## LNP0090      0.061267   0.020858   2.937 0.003352 ** 
## POLD00      -0.335543   0.089100  -3.766 0.000171 ***
## POLD90      -0.214722   0.082246  -2.611 0.009109 ** 
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.1348 on 1833 degrees of freedom
## Multiple R-squared:  0.05626,    Adjusted R-squared:  0.05471 
## F-statistic: 36.42 on 3 and 1833 DF,  p-value: &lt; 2.2e-16
</code></pre>

<p>We first convert the <code>SpatialPolygonsDataFrame</code> to a simple features or <code>sf</code> object. We use the <code>st_as_sf()</code> function from the <code>sf</code> package. </p>

<pre><code class="r">#convert to simple features
sptdmg3_sf &lt;- sf::st_as_sf(sptdmg3)
class(sptdmg3_sf)
</code></pre>

<pre><code>## [1] &quot;sf&quot;         &quot;data.frame&quot;
</code></pre>

<p>Next, we create a spatial weights matrix based on 4-nearest neighbors. We extract the coordinates from the MCD centroids using <code>st_centroid()</code> to extract the centroid of each MCD and <code>st_coordinates()</code> to extract the coordinates. We then use <code>knearneigh()</code> from the <code>spdep</code> package and specify <code>k=4</code> to create a matrix of the 4 nearest neighbors; <code>knn2nb()</code> creates a neighborhood structure object and <code>nb2listw()</code> creates a spatial weights list, where we set the style to be row-standardized weights and the zero policy to be <code>TRUE</code>. Finally, we plot the MCD and their neighbors.</p>

<pre><code class="r">#knn4
coords &lt;-st_coordinates(st_centroid(sptdmg3_sf)) #extract centroid of each  minor civil division
col.knn &lt;- knearneigh(coords, k=4)
nbknn &lt;- knn2nb(col.knn, row.names = sptdmg3$STFID)
listwk &lt;- nb2listw(nbknn, style=&quot;W&quot;)
plot(sptdmg3, main=&quot;Wisconsin: 4 Nearest-Neighbors&quot;); plot(nbknn, coords,col=&quot;forestgreen&quot;, add=TRUE)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-10"/></p>

<p>We are now ready to perform the spatio-temporal regression model. In this example, the data is already in <strong>WIDE</strong> format, meaning that every variable-year is a column in the dataset. Because of this, we directly include the lagged variables for all of the covariates as well as the lagged variable for the response, just as we had done in the simple linear model above.</p>

<pre><code class="r">#since this data is in wide format, include temporal lag for both explanatory and response variable manually
res &lt;- strm(formula2, id=&quot;STFID&quot;, data=sptdmg3_sf, listw = listwk, time=2,wide=TRUE)
</code></pre>

<pre><code>## The spatio-temporal regression model fitted:
</code></pre>

<pre><code>## LNP1000 ~ LNP0090 + POLD00 + POLD90
</code></pre>

<pre><code class="r">summary(res)
</code></pre>

<pre><code>## 
## Call:spatialreg::errorsarlm(formula = modframe, listw = listw)
## 
## Residuals:
##       Min        1Q    Median        3Q       Max 
## -0.667816 -0.068463 -0.010631  0.055872  1.053517 
## 
## Type: error 
## Coefficients: (asymptotic standard errors) 
##               Estimate Std. Error z value Pr(&gt;|z|)
## (Intercept)  0.0856035  0.0099058  8.6418  &lt; 2e-16
## LNP0090      0.0312120  0.0212166  1.4711  0.14126
## POLD00      -0.1992946  0.0863089 -2.3091  0.02094
## POLD90      -0.1665145  0.0789090 -2.1102  0.03484
## 
## Lambda: 0.28547, LR test value: 78.083, p-value: &lt; 2.22e-16
## Asymptotic standard error: 0.030315
##     z-value: 9.4169, p-value: &lt; 2.22e-16
## Wald statistic: 88.678, p-value: &lt; 2.22e-16
## 
## Log likelihood: 1115.203 for error model
## ML residual variance (sigma squared): 0.017069, (sigma: 0.13065)
## Number of observations: 1837 
## Number of parameters estimated: 6 
## AIC: -2218.4, (AIC for lm: -2142.3)
</code></pre>

</body>

</html>
